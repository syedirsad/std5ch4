import React, { useState, useEffect, useRef, useCallback } from 'react';

// Main App Component
const App = () => {
    const [currentView, setCurrentView] = useState('introToFractions'); // Default view
    const [mathJaxReady, setMathJaxReady] = useState(false); // New state to track MathJax readiness

    // Load MathJax script dynamically once for the entire application
    useEffect(() => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
        script.async = true;
        script.onload = () => {
            // Configure MathJax if needed, then typeset
            if (window.MathJax) {
                window.MathJax.startup.promise.then(() => {
                    setMathJaxReady(true); // Set MathJax as ready
                });
            }
        };
        document.head.appendChild(script);

        return () => {
            // Clean up script if component unmounts
            if (document.head.contains(script)) {
                document.head.removeChild(script);
            }
        };
    }, []);

    const renderView = () => {
        switch (currentView) {
            case 'introToFractions':
                return <IntroToFractions />;
            case 'fractionsInFlags':
                return <FractionsInFlags mathJaxReady={mathJaxReady} />;
            case 'chocolateDistribution':
                return <ChocolateDistribution mathJaxReady={mathJaxReady} />;
            case 'coloringHats':
                return <ColoringHats mathJaxReady={mathJaxReady} />;
            case 'equalPartsOfShapes':
                return <EqualPartsOfShapes />; // No MathJax needed here
            case 'patternsAndFractions':
                return <PatternsAndFractions mathJaxReady={mathJaxReady} />;
            case 'ramusFarm':
                return <RamusFarm mathJaxReady={mathJaxReady} />;
            default:
                return <IntroToFractions />;
        }
    };

    return (
        <div className="min-h-screen bg-gradient-to-br from-blue-100 to-purple-100 flex flex-col items-center p-4 font-inter">
            <h1 className="text-4xl font-extrabold text-gray-800 mb-8 text-center drop-shadow-lg">ркЧркгрк┐ркд ркЧркорлНркоркд: ркнрк╛ркЧ ркЕркирлЗ рккрлВрк░рлНркг</h1>

            <nav className="flex flex-wrap justify-center gap-3 md:gap-4 mb-8">
                <button
                    onClick={() => setCurrentView('introToFractions')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'introToFractions' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    рккрк░рк┐ркЪркп
                </button>
                <button
                    onClick={() => setCurrentView('fractionsInFlags')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'fractionsInFlags' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    ркзрлНрк╡ркЬркорк╛ркВ ркЕрккрлВрк░рлНркгрк╛ркВркХ
                </button>
                <button
                    onClick={() => setCurrentView('chocolateDistribution')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'chocolateDistribution' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    ркЪрлЛркХрк▓рлЗркЯ рк╡рк╣рлЗркВркЪркгрлА
                </button>
                <button
                    onClick={() => setCurrentView('coloringHats')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'coloringHats' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    ркЯрлЛрккрлАркУркорк╛ркВ рк░ркВркЧ рккрлВрк░рлЛ
                </button>
                <button
                    onClick={() => setCurrentView('equalPartsOfShapes')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'equalPartsOfShapes' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    ркЖркХрк╛рк░рлЛркирк╛ рк╕ркорк╛рки ркнрк╛ркЧрлЛ
                </button>
                <button
                    onClick={() => setCurrentView('patternsAndFractions')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'patternsAndFractions' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    рккрлЗркЯрк░рлНрки ркЕркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ
                </button>
                <button
                    onClick={() => setCurrentView('ramusFarm')}
                    className={`px-4 py-2 rounded-full text-sm md:text-base font-semibold transition-all duration-300 transform hover:scale-105 shadow-md
                        ${currentView === 'ramusFarm' ? 'bg-blue-600 text-white shadow-lg border-2 border-blue-800' : 'bg-white text-blue-700 hover:bg-blue-50 hover:text-blue-800 border border-blue-200'}`
                    }
                >
                    рк░рк╛ркорлБркирлБркВ ркЦрлЗркдрк░
                </button>
            </nav>

            <div className="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-6 border border-gray-200">
                {renderView()}
            </div>
        </div>
    );
};

// --- Helper Functions for Canvas Drawing ---
const drawGrid = (ctx, canvasWidth, canvasHeight, gridSize) => {
    ctx.strokeStyle = '#e0e0e0'; // Light gray for grid lines
    ctx.lineWidth = 1;

    for (let x = 0; x <= canvasWidth; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
    }
    for (let y = 0; y <= canvasHeight; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
    }
};

// Helper function to format fraction string for MathJax
const formatFractionForMathJax = (fractionStr) => {
    if (!fractionStr || fractionStr === "0") return "0";
    const parts = fractionStr.split('/');
    if (parts.length === 2) {
        return `$\\frac{${parts[0]}}{${parts[1]}}$`;
    }
    return fractionStr; // Return as is if not a simple fraction
};

// Helper function to get descriptive text for a fraction
const getFractionDescription = (numerator, denominator) => {
    if (denominator === 0) return "ркЕркорк╛ркирлНркп ркЕрккрлВрк░рлНркгрк╛ркВркХ";
    if (numerator === 0) return "0 (рк╢рлВркирлНркп ркнрк╛ркЧ)";

    let description = `${numerator}/${denominator}`;
    if (numerator === 1) {
        switch (denominator) {
            case 2: description += " (ркЕркбркзрлЛ ркнрк╛ркЧ)"; break;
            case 3: description += " (ркдрлНрк░ркгркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 4: description += " (ркЪрлЛркерлЛ ркнрк╛ркЧ)"; break;
            case 5: description += " (рккрк╛ркВркЪркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 6: description += " (ркЫркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 8: description += " (ркЖркаркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 10: description += " (ркжрк╕ркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 12: description += " (ркмрк╛рк░ркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            case 16: description += " (рк╕рлЛрк│ркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)"; break;
            default: description += ` (${denominator} ркорк╛ркВркерлА ркПркХ ркнрк╛ркЧ)`; break;
        }
    } else {
        description += ` (${denominator} ркорк╛ркВркерлА ${numerator} ркнрк╛ркЧ)`;
    }
    return description;
};


// --- 1. Introduction to Parts and Whole ---
const IntroToFractions = () => {
    const canvasRef = useRef(null);
    const [numParts, setNumParts] = useState(2); // Number of equal parts
    const [shapeType, setShapeType] = useState('circle'); // 'circle' or 'rectangle'

    const drawShape = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        if (shapeType === 'circle') {
            const radius = Math.min(centerX, centerY) * 0.8;
            for (let i = 0; i < numParts; i++) {
                const startAngle = (i * 2 * Math.PI) / numParts;
                const endAngle = ((i + 1) * 2 * Math.PI) / numParts;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = i % 2 === 0 ? '#A7F3D0' : '#FECACA'; // Light green / Light red
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw fraction text
                const midAngle = (startAngle + endAngle) / 2;
                const textX = centerX + (radius / 2) * Math.cos(midAngle);
                const textY = centerY + (radius / 2) * Math.sin(midAngle);
                ctx.fillStyle = '#000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`1/${numParts}`, textX, textY);
            }
        } else { // Rectangle
            const rectWidth = canvas.width * 0.8;
            const rectHeight = canvas.height * 0.6;
            const rectX = (canvas.width - rectWidth) / 2;
            const rectY = (canvas.height - rectHeight) / 2;

            for (let i = 0; i < numParts; i++) {
                const partWidth = rectWidth / numParts;
                ctx.fillStyle = i % 2 === 0 ? '#A7F3D0' : '#FECACA';
                ctx.fillRect(rectX + i * partWidth, rectY, partWidth, rectHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(rectX + i * partWidth, rectY, partWidth, rectHeight);

                // Draw fraction text
                ctx.fillStyle = '#000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`1/${numParts}`, rectX + i * partWidth + partWidth / 2, centerY);
            }
        }
    }, [numParts, shapeType]);

    useEffect(() => {
        drawShape();
        // MathJax is not used for canvas drawing, so no typesetPromise() here
    }, [drawShape]);

    useEffect(() => {
        const handleResize = () => drawShape();
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [drawShape]);

    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">ркнрк╛ркЧ ркЕркирлЗ рккрлВрк░рлНркгркирлЛ рккрк░рк┐ркЪркп</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркЕрк╣рлАркВ ркдркорлЗ ркПркХ рк╕ркВрккрлВрк░рлНркг рк╡рк╕рлНркдрлБркирлЗ рк╕ркорк╛рки ркнрк╛ркЧрлЛркорк╛ркВ рк╡рк┐ркнрк╛ркЬрлАркд ркХрк░рлА рк╢ркХрлЛ ркЫрлЛ ркЕркирлЗ ркжрк░рлЗркХ ркнрк╛ркЧркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркдрк░рлАркХрлЗ ркЬрлЛркИ рк╢ркХрлЛ ркЫрлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>ркЖркХрк╛рк░ рккрк╕ркВркж ркХрк░рлЛ: рк╡рк░рлНркдрлБрк│ ркХрлЗ рк▓ркВркмркЪрлЛрк░рк╕.</li>
                    <li>ркнрк╛ркЧрлЛркирлА рк╕ркВркЦрлНркпрк╛ рккрк╕ркВркж ркХрк░рлЛ ркЕркирлЗ ркЬрлБркУ ркХрлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркХрлЗрк╡рлА рк░рлАркдрлЗ ркмркжрк▓рк╛ркп ркЫрлЗ.</li>
                </ul>
            </div>
            <div className="flex gap-4 mb-4 bg-blue-50 p-3 rounded-lg shadow-inner">
                <label className="flex items-center gap-2 text-blue-800 font-medium">
                    <input type="radio" name="shapeType" value="circle" checked={shapeType === 'circle'} onChange={() => setShapeType('circle')} className="form-radio text-blue-600" />
                    рк╡рк░рлНркдрлБрк│
                </label>
                <label className="flex items-center gap-2 text-blue-800 font-medium">
                    <input type="radio" name="shapeType" value="rectangle" checked={shapeType === 'rectangle'} onChange={() => setShapeType('rectangle')} className="form-radio text-blue-600" />
                    рк▓ркВркмркЪрлЛрк░рк╕
                </label>
            </div>
            <div className="flex items-center gap-4 bg-blue-50 p-3 rounded-lg shadow-inner">
                <label htmlFor="numParts" className="font-semibold text-blue-800">ркнрк╛ркЧрлЛркирлА рк╕ркВркЦрлНркпрк╛:</label>
                <input
                    type="range"
                    id="numParts"
                    min="2"
                    max="10"
                    value={numParts}
                    onChange={(e) => setNumParts(Number(e.target.value))}
                    className="w-48 h-2 bg-blue-300 rounded-lg appearance-none cursor-pointer accent-blue-600"
                />
                <span className="font-bold text-lg text-blue-800">{numParts}</span>
            </div>
            <canvas ref={canvasRef} className="bg-white border-2 border-blue-200 rounded-xl shadow-lg w-full max-w-2xl h-96"></canvas>
        </div>
    );
};

// --- 2. Fractions in Flags Game ---
const FractionsInFlags = ({ mathJaxReady }) => {
    const feedbackRef = useRef(null); // Ref for feedback div
    const flags = [
        {
            name: "ркнрк╛рк░ркдрлАркп ркзрлНрк╡ркЬ",
            image: "https://upload.wikimedia.org/wikipedia/commons/7/7b/Flag_of_India.png", // Placeholder for Indian Flag
            sections: [
                { color: "ркХрлЗрк╕рк░рлА", fraction: "1/3" },
                { color: "рк╕рклрлЗркж (ркЪркХрлНрк░ рк╕рк╛ркерлЗ)", fraction: "1/3" },
                { color: "рк▓рлАрк▓рлЛ", fraction: "1/3" },
            ],
            question: "ркнрк╛рк░ркдрлАркп ркзрлНрк╡ркЬркорк╛ркВ ркжрк░рлЗркХ рк░ркВркЧркирлЛ ркХрлЗркЯрк▓рлЛ ркнрк╛ркЧ ркЫрлЗ?",
            correctAnswer: ["1/3", "1/3", "1/3"]
        },
        {
            name: "ркЕрклркШрк╛ркирк┐рк╕рлНркдрк╛ркиркирлЛ ркзрлНрк╡ркЬ",
            image: "https://upload.wikimedia.org/wikipedia/commons/9/9a/Flag_of_Afghanistan.svg", // Placeholder for Afghanistan Flag
            sections: [
                { color: "ркХрк╛рк│рлЛ", fraction: "1/3" },
                { color: "рк▓рк╛рк▓", fraction: "1/3" },
                { color: "рк▓рлАрк▓рлЛ", fraction: "1/3" },
            ],
            question: "ркЕрклркШрк╛ркирк┐рк╕рлНркдрк╛ркиркирк╛ ркзрлНрк╡ркЬркорк╛ркВ ркжрк░рлЗркХ рк░ркВркЧркирлЛ ркХрлЗркЯрк▓рлЛ ркнрк╛ркЧ ркЫрлЗ?",
            correctAnswer: ["1/3", "1/3", "1/3"]
        },
        {
            name: "ркорлНркпрк╛ркиркорк╛рк░ркирлЛ ркзрлНрк╡ркЬ",
            image: "https://upload.wikimedia.org/wikipedia/commons/8/8c/Flag_of_Myanmar.svg", // Placeholder for Myanmar Flag
            sections: [
                { color: "рккрлАрк│рлЛ", fraction: "1/3" },
                { color: "рк▓рлАрк▓рлЛ", fraction: "1/3" },
                { color: "рк▓рк╛рк▓", fraction: "1/3" },
            ],
            question: "ркорлНркпрк╛ркиркорк╛рк░ркирк╛ ркзрлНрк╡ркЬркорк╛ркВ ркжрк░рлЗркХ рк░ркВркЧркирлЛ ркХрлЗркЯрк▓рлЛ ркнрк╛ркЧ ркЫрлЗ?",
            correctAnswer: ["1/3", "1/3", "1/3"]
        }
    ];

    const [currentFlagIndex, setCurrentFlagIndex] = useState(0);
    const [userAnswers, setUserAnswers] = useState({});
    const [feedback, setFeedback] = useState('');

    const currentFlag = flags[currentFlagIndex];

    const handleInputChange = (color, value) => {
        setUserAnswers(prev => ({ ...prev, [color]: value }));
    };

    const handleSubmit = () => {
        let allCorrect = true;
        let newFeedback = [];
        currentFlag.sections.forEach(section => {
            const userAnswer = userAnswers[section.color];
            if (userAnswer === section.fraction) {
                newFeedback.push(`${section.color} рк░ркВркЧ ркорк╛ркЯрлЗ ркдркорк╛рк░рлЛ ркЬрк╡рк╛ркм рк╕рк╛ркЪрлЛ ркЫрлЗ!`);
            } else {
                const [num, den] = section.fraction.split('/').map(Number);
                newFeedback.push(`${section.color} рк░ркВркЧ ркорк╛ркЯрлЗ ркдркорк╛рк░рлЛ ркЬрк╡рк╛ркм ркЦрлЛркЯрлЛ ркЫрлЗ. рк╕рк╛ркЪрлЛ ркЬрк╡рк╛ркм ${formatFractionForMathJax(section.fraction)} (${getFractionDescription(num, den)}) ркЫрлЗ.`);
                allCorrect = false;
            }
        });
        setFeedback(newFeedback.join('<br>'));
    };

    const handleNextFlag = () => {
        setCurrentFlagIndex((prev) => (prev + 1) % flags.length);
        setUserAnswers({});
        setFeedback('');
    };

    // Use useEffect to typeset MathJax after feedback state updates
    useEffect(() => {
        if (mathJaxReady && feedbackRef.current && window.MathJax) {
            window.MathJax.typesetPromise([feedbackRef.current]);
        }
    }, [feedback, mathJaxReady]);


    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">ркзрлНрк╡ркЬркорк╛ркВ ркЕрккрлВрк░рлНркгрк╛ркВркХ</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркЖ рккрлНрк░рк╡рлГркдрлНркдрк┐ркорк╛ркВ, ркдркорлЗ рк╡рк┐рк╡рк┐ркз ркжрлЗрк╢рлЛркирк╛ ркзрлНрк╡ркЬркорк╛ркВ рк░ркВркЧрлЛркирк╛ ркнрк╛ркЧрлЛркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ рк╕рлНрк╡рк░рлВрккрлЗ ркУрк│ркЦрк╢рлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>ркзрлНрк╡ркЬ ркЬрлБркУ ркЕркирлЗ ркжрк░рлЗркХ рк░ркВркЧркирлЛ ркХрлЗркЯрк▓рлЛ ркнрк╛ркЧ ркЫрлЗ ркдрлЗркирлБркВ ркЕркирлБркорк╛рки ркХрк░рлЛ.</li>
                    <li>ркдркорк╛рк░рк╛ ркЬрк╡рк╛ркмрлЛ ркжрк╛ркЦрк▓ ркХрк░рлЛ ркЕркирлЗ "ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ" рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлЛ.</li>
                </ul>
            </div>
            <h3 className="text-xl font-semibold text-gray-800">{currentFlag.name}</h3>
            <img src={currentFlag.image} alt={currentFlag.name} className="w-full max-w-lg h-auto rounded-lg shadow-md border border-gray-300" onError={(e) => { e.target.onerror = null; e.target.src = `https://placehold.co/400x250/cccccc/000000?text=${currentFlag.name}`; }} />
            <p className="text-lg text-gray-700">{currentFlag.question}</p>
            <div className="flex flex-col gap-3 w-full max-w-md">
                {currentFlag.sections.map((section, index) => (
                    <div key={index} className="flex items-center gap-2">
                        <label className="w-24 text-gray-700">{section.color}:</label>
                        <input
                            type="text"
                            value={userAnswers[section.color] || ''}
                            onChange={(e) => handleInputChange(section.color, e.target.value)}
                            placeholder="ркжрк╛.ркд. 1/3"
                            className="flex-grow px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                    </div>
                ))}
            </div>
            <div className="flex gap-4">
                <button onClick={handleSubmit} className="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-200 transform hover:scale-105">ркЬрк╡рк╛ркм ркдрккрк╛рк╕рлЛ</button>
                <button onClick={handleNextFlag} className="px-5 py-2 bg-green-600 text-white rounded-lg font-semibold shadow-md hover:bg-green-700 transition-all duration-200 transform hover:scale-105">ркЖркЧрк▓рлЛ ркзрлНрк╡ркЬ</button>
            </div>
            {feedback && (
                <div ref={feedbackRef} className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                </div>
            )}
        </div>
    );
};

// --- 3. Chocolate Distribution Game ---
const ChocolateDistribution = ({ mathJaxReady }) => {
    const feedbackRef = useRef(null); // Ref for feedback div
    const totalPieces = 12; // Let's assume a chocolate bar has 12 pieces for easy division
    const [chocolatePieces, setChocolatePieces] = useState(Array(totalPieces).fill('white')); // 'white', 'red', 'blue', 'green'
    const [feedback, setFeedback] = useState('');

    const friends = [
        { name: "рк░рк╛ркЬрлА", fraction: "1/4", color: "red" },
        { name: "рк╕рлБркЧрк╛ркерк╛", fraction: "1/3", color: "blue" },
        { name: "рк╢рлАрк▓рк╛", fraction: "1/6", color: "green" },
    ];

    const calculatePieces = (fractionStr) => {
        const [numerator, denominator] = fractionStr.split('/').map(Number);
        return (totalPieces * numerator) / denominator;
    };

    const simplifyFraction = (numerator, denominator) => {
        if (numerator === 0) return "0/1";
        const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
        const commonDivisor = gcd(numerator, denominator);
        return `${numerator / commonDivisor}/${denominator / commonDivisor}`;
    };

    const handleDistribute = () => {
        let newPieces = Array(totalPieces).fill('white');
        let distributedCount = 0;

        friends.forEach(friend => {
            const piecesToGive = calculatePieces(friend.fraction);
            if (!Number.isInteger(piecesToGive) || piecesToGive < 0) {
                setFeedback(`ркЧркгркдрк░рлАркорк╛ркВ ркнрлВрк▓: ${friend.name} ркорк╛ркЯрлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркпрлЛркЧрлНркп ркиркерлА.`);
                return;
            }
            let count = 0;
            for (let i = 0; i < totalPieces; i++) {
                if (newPieces[i] === 'white' && count < piecesToGive) {
                    newPieces[i] = friend.color;
                    count++;
                    distributedCount++;
                }
            }
        });

        setChocolatePieces(newPieces);

        const manjuAte = totalPieces - distributedCount;
        const simplifiedManjuFraction = simplifyFraction(manjuAte, totalPieces);
        const [manjuNum, manjuDen] = simplifiedManjuFraction.split('/').map(Number);


        setFeedback(`
            ркЪрлЛркХрк▓рлЗркЯ рк╡рк╣рлЗркВркЪрк╛ркИ ркЧркИ ркЫрлЗ!<br>
            рк░рк╛ркЬрлАркирлЗ ${calculatePieces(friends[0].fraction)} ркЯрлБркХркбрк╛ ркорк│рлНркпрк╛.<br>
            рк╕рлБркЧрк╛ркерк╛ркирлЗ ${calculatePieces(friends[1].fraction)} ркЯрлБркХркбрк╛ ркорк│рлНркпрк╛.<br>
            рк╢рлАрк▓рк╛ркирлЗ ${calculatePieces(friends[2].fraction)} ркЯрлБркХркбрк╛ ркорк│рлНркпрк╛.<br>
            ркоркВркЬрлБркП ${manjuAte} ркЯрлБркХркбрк╛ ркЦрк╛ркзрк╛, ркЬрлЗ ркХрлБрк▓ ркЪрлЛркХрк▓рлЗркЯркирлЛ ${formatFractionForMathJax(simplifiedManjuFraction)} (${getFractionDescription(manjuNum, manjuDen)}) ркнрк╛ркЧ ркЫрлЗ.
        `);
    };

    const handleReset = () => {
        setChocolatePieces(Array(totalPieces).fill('white'));
        setFeedback('');
    };

    // Use useEffect to typeset MathJax after feedback state updates
    useEffect(() => {
        if (mathJaxReady && feedbackRef.current && window.MathJax) {
            window.MathJax.typesetPromise([feedbackRef.current]);
        }
    }, [feedback, mathJaxReady]);

    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">ркЪрлЛркХрк▓рлЗркЯ рк╡рк╣рлЗркВркЪркгрлА</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркоркВркЬрлБ рккрк╛рк╕рлЗ 12 ркЯрлБркХркбрк╛ркирлА ркПркХ ркЪрлЛркХрк▓рлЗркЯ рк╣ркдрлА. ркдрлЗркгрлЗ ркдрлЗркирк╛ ркорк┐ркдрлНрк░рлЛркирлЗ ркЪрлЛркХрлНркХрк╕ ркнрк╛ркЧ ркЖрккрлНркпрлЛ. ркмрк╛ркХрлАркирлЛ ркнрк╛ркЧ ркдрлЗ ркЦрк╛ркИ ркЧркИ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>рк░рк╛ркЬрлАркирлЗ ркЪрлЛркерлЛ ркнрк╛ркЧ (${formatFractionForMathJax("1/4")}$)</li>
                    <li>рк╕рлБркЧрк╛ркерк╛ркирлЗ ркдрлНрк░рлАркЬрлЛ ркнрк╛ркЧ (${formatFractionForMathJax("1/3")}$)</li>
                    <li>рк╢рлАрк▓рк╛ркирлЗ ркЫркарлНркарлЛ ркнрк╛ркЧ (${formatFractionForMathJax("1/6")}$)</li>
                    <li>"рк╡рк╣рлЗркВркЪркгрлА ркХрк░рлЛ" ркмркЯрки рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлЛ ркЕркирлЗ ркЬрлБркУ ркХрлЗ ркжрк░рлЗркХркирлЗ ркХрлЗркЯрк▓рк╛ ркЯрлБркХркбрк╛ ркорк│рлЗ ркЫрлЗ ркЕркирлЗ ркоркВркЬрлБркП ркХрлЗркЯрк▓рк╛ ркЦрк╛ркзрк╛.</li>
                </ul>
            </div>
            <div className="grid grid-cols-4 gap-2 border-2 border-gray-300 p-2 rounded-lg bg-gray-100 shadow-inner">
                {chocolatePieces.map((color, index) => (
                    <div key={index} className={`w-16 h-16 rounded-md shadow-sm border border-gray-200`} style={{ backgroundColor: color }}></div>
                ))}
            </div>
            <div className="flex gap-4">
                <button onClick={handleDistribute} className="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-200 transform hover:scale-105">рк╡рк╣рлЗркВркЪркгрлА ркХрк░рлЛ</button>
                <button onClick={handleReset} className="px-5 py-2 bg-red-600 text-white rounded-lg font-semibold shadow-md hover:bg-red-700 transition-all duration-200 transform hover:scale-105">рк░рлАрк╕рлЗркЯ ркХрк░рлЛ</button>
            </div>
            {feedback && (
                <div ref={feedbackRef} className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                </div>
            )}
        </div>
    );
};

// --- 4. Coloring Hats Game ---
const ColoringHats = ({ mathJaxReady }) => {
    const feedbackRef = useRef(null); // Ref for feedback div
    const totalHats = 15; // A number easily divisible by common denominators (3, 5)
    const [hats, setHats] = useState(Array(totalHats).fill('white'));
    const [feedback, setFeedback] = useState('');

    const simplifyFraction = (numerator, denominator) => {
        if (numerator === 0) return "0/1";
        const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
        const commonDivisor = gcd(numerator, denominator);
        return `${numerator / commonDivisor}/${denominator / commonDivisor}`;
    };

    const colorHats = () => {
        const newHats = Array(totalHats).fill('white');

        // Color 1/3 red
        const redHatsCount = Math.floor(totalHats / 3);
        for (let i = 0; i < redHatsCount; i++) {
            newHats[i] = 'red';
        }

        // Color 3/5 blue (from remaining or overall? Let's assume overall for simplicity)
        // To avoid overlapping, we'll pick from the remaining white hats.
        const blueHatsCount = Math.floor(totalHats * 3 / 5);
        let blueCount = 0;
        for (let i = 0; i < totalHats && blueCount < blueHatsCount; i++) {
            if (newHats[i] === 'white') {
                newHats[i] = 'blue';
                blueCount++;
            }
        }
        setHats(newHats);

        const uncoloredHats = newHats.filter(hat => hat === 'white').length;

        setFeedback(`
            ркЯрлЛрккрлАркУркорк╛ркВ рк░ркВркЧ рккрлВрк░рк╛ркИ ркЧркпрлЛ ркЫрлЗ!<br>
            рк▓рк╛рк▓ ркЯрлЛрккрлАркУ: ${redHatsCount} (${formatFractionForMathJax(simplifyFraction(redHatsCount, totalHats))})<br>
            рк╡рк╛ркжрк│рлА ркЯрлЛрккрлАркУ: ${blueHatsCount} (${formatFractionForMathJax(simplifyFraction(blueHatsCount, totalHats))})<br>
            рк░ркВркЧ рк╡ркЧрк░ркирлА ркЯрлЛрккрлАркУ: ${uncoloredHats} (${formatFractionForMathJax(simplifyFraction(uncoloredHats, totalHats))})
        `);
    };

    const handleReset = () => {
        setHats(Array(totalHats).fill('white'));
        setFeedback('');
    };

    // Use useEffect to typeset MathJax after feedback state updates
    useEffect(() => {
        if (mathJaxReady && feedbackRef.current && window.MathJax) {
            window.MathJax.typesetPromise([feedbackRef.current]);
        }
    }, [feedback, mathJaxReady]);

    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">ркЯрлЛрккрлАркУркорк╛ркВ рк░ркВркЧ рккрлВрк░рлЛ</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркЖ рккрлНрк░рк╡рлГркдрлНркдрк┐ркорк╛ркВ, ркдркорлЗ ркЯрлЛрккрлАркУркирк╛ рк╕ркВркЧрлНрк░рк╣ркирк╛ ркЪрлЛркХрлНркХрк╕ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркнрк╛ркЧркорк╛ркВ рк░ркВркЧ рккрлВрк░рлАркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХркирлЗ рк╕ркоркЬрлА рк╢ркХрлЛ ркЫрлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>ркХрлБрк▓ ркЯрлЛрккрлАркУ: {totalHats}</li>
                    <li>${formatFractionForMathJax("1/3")}$ (${getFractionDescription(1, 3)}) ркЯрлЛрккрлАркУркорк╛ркВ рк▓рк╛рк▓ рк░ркВркЧ рккрлВрк░рлЛ.</li>
                    <li>${formatFractionForMathJax("3/5")}$ (${getFractionDescription(3, 5)}) ркЯрлЛрккрлАркУркорк╛ркВ рк╡рк╛ркжрк│рлА рк░ркВркЧ рккрлВрк░рлЛ.</li>
                    <li>"рк░ркВркЧ рккрлВрк░рлЛ" ркмркЯрки рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлЛ ркЕркирлЗ рккрк░рк┐ркгрк╛рко ркЬрлБркУ.</li>
                </ul>
            </div>
            <div className="grid grid-cols-5 gap-3 bg-gray-100 p-3 rounded-xl shadow-inner">
                {hats.map((color, index) => (
                    <div key={index} className="w-20 h-20 flex items-center justify-center rounded-full shadow-md border border-gray-200" style={{ backgroundColor: color }}>
                        <span role="img" aria-label="hat" className="text-4xl">ЁЯОй</span>
                    </div>
                ))}
            </div>
            <div className="flex gap-4">
                <button onClick={colorHats} className="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-200 transform hover:scale-105">рк░ркВркЧ рккрлВрк░рлЛ</button>
                <button onClick={handleReset} className="px-5 py-2 bg-red-600 text-white rounded-lg font-semibold shadow-md hover:bg-red-700 transition-all duration-200 transform hover:scale-105">рк░рлАрк╕рлЗркЯ ркХрк░рлЛ</button>
            </div>
            {feedback && (
                <div ref={feedbackRef} className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                </div>
            )}
        </div>
    );
};

// --- 5. Equal Parts of Shapes Game ---
const EqualPartsOfShapes = () => {
    const canvasRef = useRef(null);
    const [shapeType, setShapeType] = useState('rectangle'); // 'rectangle' or 'triangle'
    const [numDivisions, setNumDivisions] = useState(2);
    const [lines, setLines] = useState([]); // Stores line segments for drawing
    const [feedback, setFeedback] = useState('');
    const [isDrawing, setIsDrawing] = useState(false);
    const [startPoint, setStartPoint] = useState(null);

    const drawShapeAndLines = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        const mainShape = {};
        if (shapeType === 'rectangle') {
            mainShape.x = canvas.width * 0.2;
            mainShape.y = canvas.height * 0.2;
            mainShape.width = canvas.width * 0.6;
            mainShape.height = canvas.height * 0.6;
            ctx.strokeRect(mainShape.x, mainShape.y, mainShape.width, mainShape.height);
        } else { // Triangle
            mainShape.p1 = { x: canvas.width / 2, y: canvas.height * 0.2 };
            mainShape.p2 = { x: canvas.width * 0.8, y: canvas.height * 0.8 };
            mainShape.p3 = { x: canvas.width * 0.2, y: canvas.height * 0.8 };
            ctx.beginPath();
            ctx.moveTo(mainShape.p1.x, mainShape.p1.y);
            ctx.lineTo(mainShape.p2.x, mainShape.p2.y);
            ctx.lineTo(mainShape.p3.x, mainShape.p3.y);
            ctx.closePath();
            ctx.stroke();
        }

        // Draw user-drawn lines
        ctx.strokeStyle = '#ef4444'; // Red for user lines
        ctx.lineWidth = 2;
        lines.forEach(line => {
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.stroke();
        });

        // Simple check for equal parts (visual inspection for now)
        // More complex logic would involve calculating areas of sub-polygons
        if (lines.length === numDivisions - 1) { // If enough lines are drawn
            setFeedback("ркдркорлЗ рккрлВрк░ркдрлА рк░рлЗркЦрк╛ркУ ркжрлЛрк░рлА ркЫрлЗ. рк╣рк╡рлЗ ркдрккрк╛рк╕рлЛ ркХрлЗ ркнрк╛ркЧрлЛ рк╕ркорк╛рки ркЫрлЗ ркХрлЗ ркирк╣рлАркВ!");
        } else if (lines.length > 0) {
            setFeedback(`рк╡ркзрлБ ${numDivisions - 1 - lines.length} рк░рлЗркЦрк╛ркУ ркжрлЛрк░рлЛ.`);
        } else {
            setFeedback(`ркЖркХрк╛рк░ркирлЗ ${numDivisions} рк╕ркорк╛рки ркнрк╛ркЧрлЛркорк╛ркВ рк╡рк┐ркнрк╛ркЬрлАркд ркХрк░рк╡рк╛ ркорк╛ркЯрлЗ рк░рлЗркЦрк╛ркУ ркжрлЛрк░рлЛ.`);
        }

    }, [shapeType, numDivisions, lines]);

    useEffect(() => {
        drawShapeAndLines();
    }, [drawShapeAndLines]);

    const handleMouseDown = (e) => {
        if (lines.length >= numDivisions - 1) return; // Stop drawing if enough lines

        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        setIsDrawing(true);
        setStartPoint({ x: mouseX, y: mouseY });
    };

    const handleMouseMove = (e) => {
        if (!isDrawing) return;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Temporarily draw current line segment
        drawShapeAndLines(); // Redraw base shape and existing lines
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(mouseX, mouseY);
        ctx.stroke();
    };

    const handleMouseUp = (e) => {
        if (!isDrawing) return;
        setIsDrawing(false);

        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        setLines(prevLines => [...prevLines, { start: startPoint, end: { x: mouseX, y: mouseY } }]);
        setStartPoint(null);
    };

    const handleReset = () => {
        setLines([]);
        setFeedback('');
        setIsDrawing(false);
        setStartPoint(null);
    };

    useEffect(() => {
        const handleResize = () => drawShapeAndLines();
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [drawShapeAndLines]);

    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">ркЖркХрк╛рк░рлЛркирк╛ рк╕ркорк╛рки ркнрк╛ркЧрлЛ</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркЖ рккрлНрк░рк╡рлГркдрлНркдрк┐ркорк╛ркВ, ркдркорлЗ рк╡рк┐рк╡рк┐ркз ркнрлМркорк┐ркдрк┐ркХ ркЖркХрк╛рк░рлЛркирлЗ рк╕ркорк╛рки ркнрк╛ркЧрлЛркорк╛ркВ рк╡рк┐ркнрк╛ркЬрлАркд ркХрк░рк╡рк╛ркирлЛ рккрлНрк░ркпрк╛рк╕ ркХрк░рк╢рлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>ркЖркХрк╛рк░ (рк▓ркВркмркЪрлЛрк░рк╕ ркХрлЗ ркдрлНрк░рк┐ркХрлЛркг) ркЕркирлЗ ркнрк╛ркЧрлЛркирлА рк╕ркВркЦрлНркпрк╛ рккрк╕ркВркж ркХрк░рлЛ.</li>
                    <li>ркХрлЗркирк╡рк╛рк╕ рккрк░ ркорк╛ркЙрк╕ ркХрлНрк▓рк┐ркХ ркХрк░рлАркирлЗ ркЕркирлЗ ркЦрлЗркВркЪрлАркирлЗ рк░рлЗркЦрк╛ркУ ркжрлЛрк░рлЛ ркЬрлЗркерлА ркЖркХрк╛рк░ рк╕ркорк╛рки ркнрк╛ркЧрлЛркорк╛ркВ рк╡рк╣рлЗркВркЪрк╛ркИ ркЬрк╛ркп.</li>
                    <li>ркирлЛркВркз: ркЖ рккрлНрк░рк╡рлГркдрлНркдрк┐ркорк╛ркВ, ркнрк╛ркЧрлЛ рк╕ркорк╛рки ркЫрлЗ ркХрлЗ ркирк╣рлАркВ ркдрлЗ ркдркорк╛рк░рлЗ ркЬрк╛ркдрлЗ ркЬ ркдрккрк╛рк╕рк╡рк╛ркирлБркВ ркЫрлЗ.</li>
                </ul>
            </div>
            <div className="flex gap-4 mb-4 bg-blue-50 p-3 rounded-lg shadow-inner">
                <label className="flex items-center gap-2 text-blue-800 font-medium">
                    <input type="radio" name="shapeDivType" value="rectangle" checked={shapeType === 'rectangle'} onChange={() => { setShapeType('rectangle'); handleReset(); }} />
                    рк▓ркВркмркЪрлЛрк░рк╕
                </label>
                <label className="flex items-center gap-2 text-blue-800 font-medium">
                    <input type="radio" name="shapeDivType" value="triangle" checked={shapeType === 'triangle'} onChange={() => { setShapeType('triangle'); handleReset(); }} />
                    ркдрлНрк░рк┐ркХрлЛркг
                </label>
            </div>
            <div className="flex items-center gap-4 bg-blue-50 p-3 rounded-lg shadow-inner">
                <label htmlFor="numDivisions" className="font-semibold text-blue-800">ркнрк╛ркЧрлЛркирлА рк╕ркВркЦрлНркпрк╛:</label>
                <input
                    type="range"
                    id="numDivisions"
                    min="2"
                    max="5"
                    value={numDivisions}
                    onChange={(e) => { setNumDivisions(Number(e.target.value)); handleReset(); }}
                    className="w-48 h-2 bg-blue-300 rounded-lg appearance-none cursor-pointer accent-blue-600"
                />
                <span className="font-bold text-lg">{numDivisions}</span>
            </div>
            <canvas
                ref={canvasRef}
                className="bg-white border-2 border-blue-200 rounded-xl shadow-lg w-full max-w-2xl h-96 cursor-crosshair"
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp} // Stop drawing if mouse leaves canvas
            ></canvas>
            <div className="flex gap-4">
                <button onClick={handleReset} className="px-5 py-2 bg-red-600 text-white rounded-lg font-semibold shadow-md hover:bg-red-700 transition-all duration-200 transform hover:scale-105">рк░рлАрк╕рлЗркЯ ркХрк░рлЛ</button>
            </div>
            {feedback && (
                <div className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                    {feedback}
                </div>
            )}
        </div>
    );
};


// --- 6. Patterns and Fractions Game ---
const PatternsAndFractions = ({ mathJaxReady }) => {
    const feedbackRef = useRef(null); // Ref for feedback div
    const gridSize = 4; // 4x4 grid = 16 squares
    const totalSquares = gridSize * gridSize;
    const [coloredSquares, setColoredSquares] = useState(Array(totalSquares).fill('white'));
    const [feedback, setFeedback] = useState('');

    const patterns = [
        {
            description: `$\\frac{2}{8}$ (${getFractionDescription(2, 8)}) рк▓рк╛рк▓, $\\frac{1}{2}$ (${getFractionDescription(1, 2)}) рккрлАрк│рлЛ, $\\frac{1}{4}$ (${getFractionDescription(1, 4)}) рк▓рлАрк▓рлЛ`,
            fractions: { red: "2/8", yellow: "1/2", green: "1/4" }
        },
        {
            description: `$\\frac{3}{16}$ (${getFractionDescription(3, 16)}) рк╡рк╛ркжрк│рлА, $\\frac{5}{16}$ (${getFractionDescription(5, 16)}) рккрлАрк│рлЛ, ркмрк╛ркХрлАркирлЛ рк╕рклрлЗркж`,
            fractions: { blue: "3/16", yellow: "5/16" }
        },
    ];

    const [currentPatternIndex, setCurrentPatternIndex] = useState(0);

    const calculateSquaresToColor = (fractionStr) => {
        const [numerator, denominator] = fractionStr.split('/').map(Number);
        return (totalSquares * numerator) / denominator;
    };

    const simplifyFraction = (numerator, denominator) => {
        if (numerator === 0) return "0/1";
        const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
        const commonDivisor = gcd(numerator, denominator);
        return `${numerator / commonDivisor}/${denominator / commonDivisor}`;
    };

    const applyPattern = useCallback(() => {
        const newSquares = Array(totalSquares).fill('white');
        const currentPattern = patterns[currentPatternIndex];

        // Shuffle indices to distribute colors somewhat randomly
        const indices = Array.from({ length: totalSquares }, (_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        let coloredCount = 0;
        for (const color in currentPattern.fractions) {
            const count = calculateSquaresToColor(currentPattern.fractions[color]);
            let currentColored = 0;
            for (let i = 0; i < totalSquares && currentColored < count; i++) {
                const idx = indices[i]; // Use shuffled index
                if (newSquares[idx] === 'white') {
                    newSquares[idx] = color;
                    currentColored++;
                    coloredCount++;
                }
            }
        }
        setColoredSquares(newSquares);

        const whiteSquares = totalSquares - coloredCount;
        setFeedback(`
            рккрлЗркЯрк░рлНрки рк▓рк╛ркЧрлБ ркеркИ ркЧркИ ркЫрлЗ!<br>
            рк╕рклрлЗркж ркнрк╛ркЧ: ${formatFractionForMathJax(simplifyFraction(whiteSquares, totalSquares))} (${getFractionDescription(whiteSquares, totalSquares)})
        `);
    }, [currentPatternIndex]);

    useEffect(() => {
        applyPattern();
    }, [applyPattern]);

    const handleNextPattern = () => {
        setCurrentPatternIndex((prev) => (prev + 1) % patterns.length);
        setFeedback('');
    };

    // Use useEffect to typeset MathJax after feedback state updates
    useEffect(() => {
        if (mathJaxReady && feedbackRef.current && window.MathJax) {
            window.MathJax.typesetPromise([feedbackRef.current]);
        }
    }, [feedback, mathJaxReady]);


    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">рккрлЗркЯрк░рлНрки ркЕркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>ркЖ рккрлНрк░рк╡рлГркдрлНркдрк┐ркорк╛ркВ, ркдркорлЗ ркЧрлНрк░рлАркб рккрк░ ркЖрккрлЗрк▓ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркорлБркЬркм ркЪрлЛрк░рк╕ркорк╛ркВ рк░ркВркЧ рккрлВрк░рлАркирлЗ рккрлЗркЯрк░рлНрки ркмркирк╛рк╡рк╢рлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>ркЖрккрлЗрк▓ ркЕрккрлВрк░рлНркгрк╛ркВркХ ркорлБркЬркм ркЪрлЛрк░рк╕ркорк╛ркВ рк░ркВркЧ рккрлВрк░рлЛ.</li>
                    <li>"рккрлЗркЯрк░рлНрки рк▓рк╛ркЧрлБ ркХрк░рлЛ" ркмркЯрки рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлЛ.</li>
                    <li>рк░ркВркЧрлАрки ркЕркирлЗ рк╕рклрлЗркж ркнрк╛ркЧрлЛркирлЗ ркЕрккрлВрк░рлНркгрк╛ркВркХ рк╕рлНрк╡рк░рлВрккрлЗ ркЬрлБркУ.</li>
                </ul>
            </div>
            <div className="text-lg font-semibold text-gray-800" dangerouslySetInnerHTML={{ __html: patterns[currentPatternIndex].description }}>
            </div>
            <div className="grid bg-gray-100 p-3 rounded-xl shadow-inner" style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)`, gap: '4px' }}>
                {coloredSquares.map((color, index) => (
                    <div key={index} className="w-16 h-16 border border-gray-300 rounded-sm" style={{ backgroundColor: color }}></div>
                ))}
            </div>
            <div className="flex gap-4">
                <button onClick={applyPattern} className="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-200 transform hover:scale-105">рккрлЗркЯрк░рлНрки рк▓рк╛ркЧрлБ ркХрк░рлЛ</button>
                <button onClick={handleNextPattern} className="px-5 py-2 bg-green-600 text-white rounded-lg font-semibold shadow-md hover:bg-green-700 transition-all duration-200 transform hover:scale-105">ркЖркЧрк▓рлА рккрлЗркЯрк░рлНрки</button>
            </div>
            {feedback && (
                <div ref={feedbackRef} className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                </div>
            )}
        </div>
    );
};

// --- 7. Ramu's Vegetable Farm Game ---
const RamusFarm = ({ mathJaxReady }) => {
    const feedbackRef = useRef(null); // Ref for feedback div
    const farmGridSize = 3; // 3x3 grid
    const totalFarmSections = farmGridSize * farmGridSize; // 9 sections
    const [farmSections, setFarmSections] = useState(Array(totalFarmSections).fill('empty')); // 'empty', 'chilli', 'potato', 'brinjal', 'spinach', 'tomato'
    const [feedback, setFeedback] = useState('');

    const vegetableMap = {
        0: 'chilli', 1: 'potato', 2: 'brinjal',
        3: 'brinjal', 4: 'tomato', 5: 'spinach',
        6: 'tomato', 7: 'potato', 8: 'tomato'
    };

    const vegetableColors = {
        chilli: '#22c55e', // Green
        potato: '#d97706', // Orange
        brinjal: '#8b5cf6', // Purple
        spinach: '#16a34a', // Dark Green
        tomato: '#ef4444', // Red
        empty: '#f3f4f6' // Light gray
    };

    const vegetableNames = {
        chilli: 'ркорк░ркЪрк╛ркВ',
        potato: 'ркмркЯрк╛ркХрк╛',
        brinjal: 'рк░рлАркВркЧркг',
        spinach: 'рккрк╛рк▓ркХ',
        tomato: 'ркЯркорлЗркЯрк╛ркВ'
    };

    useEffect(() => {
        const initialFarm = Array(totalFarmSections).fill('empty');
        for (let i = 0; i < totalFarmSections; i++) {
            initialFarm[i] = vegetableMap[i];
        }
        setFarmSections(initialFarm);
    }, []);

    const simplifyFraction = (numerator, denominator) => {
        if (numerator === 0) return "0/1";
        const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
        const commonDivisor = gcd(numerator, denominator);
        return `${numerator / commonDivisor}/${denominator / commonDivisor}`;
    };

    const analyzeFarm = () => {
        const counts = {};
        farmSections.forEach(veg => {
            counts[veg] = (counts[veg] || 0) + 1;
        });

        let analysis = [];
        let maxVeg = '';
        let maxCount = 0;

        for (const veg in counts) {
            if (veg === 'empty') continue;
            const fraction = simplifyFraction(counts[veg], totalFarmSections);
            const [num, den] = fraction.split('/').map(Number);
            analysis.push(`${vegetableNames[veg]}: ${counts[veg]} ркнрк╛ркЧ (${formatFractionForMathJax(fraction)} ркЕркерк╡рк╛ ${getFractionDescription(num, den)})`);
            if (counts[veg] > maxCount) {
                maxCount = counts[veg];
                maxVeg = vegetableNames[veg];
            }
        }
        const maxFraction = simplifyFraction(maxCount, totalFarmSections);
        const [maxNum, maxDen] = maxFraction.split('/').map(Number);
        analysis.unshift(`ркЦрлЗркдрк░ркирк╛ рк╕рлМркерлА ркорлЛркЯрк╛ ркнрк╛ркЧркорк╛ркВ ${maxVeg} ркЙркЧрк╛ркбрлЗ ркЫрлЗ. (${formatFractionForMathJax(maxFraction)} ркЕркерк╡рк╛ ${getFractionDescription(maxNum, maxDen)} ркнрк╛ркЧ)`);
        setFeedback(analysis.join('<br>'));
    };

    const handleDistribution = () => {
        const totalTomatoes = 3; // From map: 4, 6, 8
        const totalPotatoes = 2; // From map: 1, 7

        // Ramu gives:
        // Abubakr: 1/5 of tomatoes, 1/3 of potatoes
        const abubakrTomatoes = Math.floor(totalTomatoes * (1/5)); // 0 for 3 tomatoes
        const abubakrPotatoes = Math.floor(totalPotatoes * (1/3)); // 0 for 2 potatoes

        // Shrija: 2/5 of tomatoes, 3/6 (1/2) of potatoes
        const shrijaTomatoes = Math.floor(totalTomatoes * (2/5)); // 1 for 3 tomatoes
        const shrijaPotatoes = Math.floor(totalPotatoes * (3/6)); // 1 for 2 potatoes

        // Nancy gets the rest
        const nancyTomatoes = totalTomatoes - abubakrTomatoes - shrijaTomatoes;
        const nancyPotatoes = totalPotatoes - abubakrPotatoes - shrijaPotatoes;

        setFeedback(`
            рк╢рк╛ркХркнрк╛ркЬрлАркирлА рк╡рк╣рлЗркВркЪркгрлА:<br>
            ркЕркмрлБркмркХрк░ркирлЗ ркорк│рлНркпрк╛: ${abubakrTomatoes} ркЯркорлЗркЯрк╛ркВ, ${abubakrPotatoes} ркмркЯрк╛ркХрк╛.<br>
            рк╢рлНрк░рлАркЬрк╛ркирлЗ ркорк│рлНркпрк╛: ${shrijaTomatoes} ркЯркорлЗркЯрк╛ркВ, ${shrijaPotatoes} ркмркЯрк╛ркХрк╛.<br>
            ркирлЗркирлНрк╕рлАркирлЗ ркорк│рлНркпрк╛: ${nancyTomatoes} ркЯркорлЗркЯрк╛ркВ, ${nancyPotatoes} ркмркЯрк╛ркХрк╛.
        `);
    };

    // Use useEffect to typeset MathJax after feedback state updates
    useEffect(() => {
        if (mathJaxReady && feedbackRef.current && window.MathJax) {
            window.MathJax.typesetPromise([feedbackRef.current]);
        }
    }, [feedback, mathJaxReady]);

    return (
        <div className="flex flex-col items-center gap-6">
            <h2 className="text-2xl font-bold text-gray-700">рк░рк╛ркорлБркирлБркВ рк╢рк╛ркХркнрк╛ркЬрлАркирлБркВ ркЦрлЗркдрк░</h2>
            <div className="instructions bg-yellow-50 border border-yellow-300 p-4 rounded-lg text-sm text-yellow-800 shadow-sm">
                <p>рк░рк╛ркорлБркирк╛ рк╢рк╛ркХркнрк╛ркЬрлАркирк╛ ркЦрлЗркдрк░ркирк╛ 9 рк╕рк░ркЦрк╛ ркнрк╛ркЧ ркХрк░рлЗрк▓рк╛ ркЫрлЗ. ркдрлЗ ркдрлЗркирк╛ ркЦрлЗркдрк░ркорк╛ркВ ркХркИ-ркХркИ рк╢рк╛ркХркнрк╛ркЬрлА ркЙркЧрк╛ркбрлЗ ркЫрлЗ ркдрлЗ ркЬрлБркУ ркЕркирлЗ рккрлНрк░рк╢рлНркирлЛркирк╛ ркЬрк╡рк╛ркм ркЖрккрлЛ.</p>
                <ul className="list-disc ml-5 mt-2">
                    <li>"ркЦрлЗркдрк░ркирлБркВ рк╡рк┐рк╢рлНрк▓рлЗрк╖ркг ркХрк░рлЛ" рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлАркирлЗ ркжрк░рлЗркХ рк╢рк╛ркХркнрк╛ркЬрлАркирлЛ ркХрлЗркЯрк▓рлЛ ркнрк╛ркЧ ркЫрлЗ ркдрлЗ ркЬрк╛ркгрлЛ.</li>
                    <li>"рк╡рк╣рлЗркВркЪркгрлА ркЬрлБркУ" рккрк░ ркХрлНрк▓рк┐ркХ ркХрк░рлАркирлЗ рк░рк╛ркорлБ ркдрлЗркирк╛ ркорк┐ркдрлНрк░рлЛркирлЗ рк╢рк╛ркХркнрк╛ркЬрлА ркХрлЗрк╡рлА рк░рлАркдрлЗ рк╡рк╣рлЗркВркЪрлЗ ркЫрлЗ ркдрлЗ ркЬрлБркУ.</li>
                </ul>
            </div>
            <div className="grid grid-cols-3 gap-2 border-2 border-gray-300 p-2 rounded-lg bg-gray-100 shadow-inner">
                {farmSections.map((veg, index) => (
                    <div key={index} className="w-24 h-24 flex items-center justify-center rounded-md" style={{ backgroundColor: vegetableColors[veg] }}>
                        <span className="text-sm font-semibold text-white text-shadow-sm">{vegetableNames[veg]}</span>
                    </div>
                ))}
            </div>
            <div className="flex gap-4">
                <button onClick={analyzeFarm} className="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition-all duration-200 transform hover:scale-105">ркЦрлЗркдрк░ркирлБркВ рк╡рк┐рк╢рлНрк▓рлЗрк╖ркг ркХрк░рлЛ</button>
                <button onClick={handleDistribution} className="px-5 py-2 bg-purple-600 text-white rounded-lg font-semibold shadow-md hover:bg-purple-700 transition-all duration-200 transform hover:scale-105">рк╡рк╣рлЗркВркЪркгрлА ркЬрлБркУ</button>
            </div>
            {feedback && (
                <div ref={feedbackRef} className="bg-blue-100 px-4 py-2 rounded-md shadow-sm text-gray-700 font-medium border border-blue-200">
                </div>
            )}
        </div>
    );
};

export default App;
